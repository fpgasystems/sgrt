<?xml version="1.0" encoding="UTF-8"?>
<spirit:component xmlns:xilinx="http://www.xilinx.com" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <spirit:vendor>xilinx.com</spirit:vendor>
  <spirit:library>ip</spirit:library>
  <spirit:name>smbus</spirit:name>
  <spirit:version>1.1</spirit:version>
  <spirit:busInterfaces>
    <spirit:busInterface>
      <spirit:name>S_AXI</spirit:name>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="aximm" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="aximm_rtl" spirit:version="1.0"/>
      <spirit:slave>
        <spirit:memoryMapRef spirit:memoryMapRef="S_AXI"/>
      </spirit:slave>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARADDR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_araddr</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_arready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>ARVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_arvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWADDR</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awaddr</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>AWVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_awvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BRESP</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bresp</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>BVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_bvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RRESP</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rresp</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_rvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WDATA</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wdata</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WREADY</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wready</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WSTRB</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wstrb</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>WVALID</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_wvalid</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>RESET</spirit:name>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="reset_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>RST</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_aresetn</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>POLARITY</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.RESET.POLARITY" spirit:choiceRef="choice_list_74b5137e">ACTIVE_LOW</spirit:value>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>CLOCK</spirit:name>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="clock_rtl" spirit:version="1.0"/>
      <spirit:slave/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>CLK</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>s_axi_aclk</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_BUSIF</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.CLOCK.ASSOCIATED_BUSIF">S_AXI</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>ASSOCIATED_RESET</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.CLOCK.ASSOCIATED_RESET">s_axi_aresetn</spirit:value>
        </spirit:parameter>
        <spirit:parameter>
          <spirit:name>FREQ_HZ</spirit:name>
          <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="BUSIFPARAM_VALUE.CLOCK.FREQ_HZ">100000000</spirit:value>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>INTERRUPT</spirit:name>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="interrupt" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="signal" spirit:name="interrupt_rtl" spirit:version="1.0"/>
      <spirit:master/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>INTERRUPT</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>ip2intc_irpt</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
      <spirit:parameters>
        <spirit:parameter>
          <spirit:name>SENSITIVITY</spirit:name>
          <spirit:value spirit:id="BUSIFPARAM_VALUE.INTERRUPT.SENSITIVITY">LEVEL_HIGH</spirit:value>
        </spirit:parameter>
      </spirit:parameters>
    </spirit:busInterface>
    <spirit:busInterface>
      <spirit:name>SMBUS</spirit:name>
      <spirit:busType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="iic" spirit:version="1.0"/>
      <spirit:abstractionType spirit:vendor="xilinx.com" spirit:library="interface" spirit:name="iic_rtl" spirit:version="1.0"/>
      <spirit:master/>
      <spirit:portMaps>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SCL_I</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbclk_i</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SCL_O</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbclk_o</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SCL_T</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbclk_t</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SDA_I</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbdat_i</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SDA_O</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbdat_o</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
        <spirit:portMap>
          <spirit:logicalPort>
            <spirit:name>SDA_T</spirit:name>
          </spirit:logicalPort>
          <spirit:physicalPort>
            <spirit:name>smbdat_t</spirit:name>
          </spirit:physicalPort>
        </spirit:portMap>
      </spirit:portMaps>
    </spirit:busInterface>
  </spirit:busInterfaces>
  <spirit:memoryMaps>
    <spirit:memoryMap>
      <spirit:name>S_AXI</spirit:name>
      <spirit:addressBlock>
        <spirit:name>Reg</spirit:name>
        <spirit:baseAddress spirit:format="bitString" spirit:resolve="user" spirit:bitStringLength="32">0</spirit:baseAddress>
        <spirit:range spirit:format="long" spirit:resolve="dependent" spirit:dependency="pow(2,(spirit:decode(id(&apos;MODELPARAM_VALUE.C_ADDR_WIDTH&apos;)) - 1) + 1)">4096</spirit:range>
        <spirit:width spirit:format="long">32</spirit:width>
        <spirit:usage>register</spirit:usage>
        <spirit:access>read-write</spirit:access>
        <spirit:register>
          <spirit:name>IP_VERSION</spirit:name>
          <spirit:displayName>IP_VERSION</spirit:displayName>
          <spirit:description>IP Major/Minor Version Information Register</spirit:description>
          <spirit:addressOffset>0x000</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="dependent" spirit:dependency="((spirit:decode(id(&apos;MODELPARAM_VALUE.C_MAJOR_VERSION&apos;)) * 65536) + (spirit:decode(id(&apos;MODELPARAM_VALUE.C_MINOR_VERSION&apos;))))">65536</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>MAJOR_VERSION</spirit:name>
            <spirit:displayName>MAJOR_VERSION</spirit:displayName>
            <spirit:description>IP Major Version
Returns the IP Major Version
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>MINOR_VERSION</spirit:name>
            <spirit:displayName>MINOR_VERSION</spirit:displayName>
            <spirit:description>IP Minor Version
Returns the IP Minor Version
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IP_REVISION</spirit:name>
          <spirit:displayName>IP_REVISION</spirit:displayName>
          <spirit:description>IP Revision Information Register</spirit:description>
          <spirit:addressOffset>0x004</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_CORE_REVISION&apos;)))">0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CORE_REVISION</spirit:name>
            <spirit:displayName>CORE_REVISION</spirit:displayName>
            <spirit:description>IP Core Revision
Returns the IP Core Revision
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IP_MAGIC_NUM</spirit:name>
          <spirit:displayName>IP_MAGIC_NUM</spirit:displayName>
          <spirit:description>IP Magic Number Register</spirit:description>
          <spirit:addressOffset>0x008</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x534D4273</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>MAGIC_NUMBER</spirit:name>
            <spirit:displayName>MAGIC_NUMBER</spirit:displayName>
            <spirit:description>IP Magic Number
Returns a read-only identifier to assist with debug/bring-up.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IP_BUILD_CONFIG_0</spirit:name>
          <spirit:displayName>IP_BUILD_CONFIG_0</spirit:displayName>
          <spirit:description>IP Build Configuration 0 Register</spirit:description>
          <spirit:addressOffset>0x00C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;PARAM_VALUE.FREQ_HZ_AXI_ACLK&apos;)))">100000000</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FREQ_HZ_AXI_ACLK</spirit:name>
            <spirit:displayName>FREQ_HZ_AXI_ACLK</spirit:displayName>
            <spirit:description>Input AXI ACLK Frequency
Returns the value of the FREQ_HZ_AXI_ACLK parameter as configured at build time.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>32</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IP_BUILD_CONFIG_1</spirit:name>
          <spirit:displayName>IP_BUILD_CONFIG_1</spirit:displayName>
          <spirit:description>IP Build Configuration 1 Register</spirit:description>
          <spirit:addressOffset>0x010</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long" spirit:resolve="dependent" spirit:dependency="((spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) * 16) + (spirit:decode(id(&apos;PARAM_VALUE.SMBUS_DEV_CLASS&apos;))))">128</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>NUM_TARGET_DEVICES</spirit:name>
            <spirit:displayName>NUM_TARGET_DEVICES</spirit:displayName>
            <spirit:description>Number of Target Devices supported
Returns the value of the NUM_TARGET_DEVICES parameter as configured at build time.
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SMBUS_DEV_CLASS</spirit:name>
            <spirit:displayName>SMBUS_DEV_CLASS</spirit:displayName>
            <spirit:description>Default SMBus Device Class
Returns the value of the SMBUS_DEV_CLASS parameter as configured at build time.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>2</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IRQ_GIE</spirit:name>
          <spirit:displayName>IRQ_GIE</spirit:displayName>
          <spirit:description>Global Interrupt Enable Register</spirit:description>
          <spirit:addressOffset>0x020</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Global Interrupt Enable
When set, interrupts enabled in the IRQ_IER register can assert the ip2intc_irpt interrupt output.
0x0 - Disable the interrupt output
0x1 - Enable the interrupt output
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IRQ_IER</spirit:name>
          <spirit:displayName>IRQ_IER</spirit:displayName>
          <spirit:description>Interrupt Enable Register</spirit:description>
          <spirit:addressOffset>0x024</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_ALMOST_EMPTY</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Almost Empty Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_DESC_FIFO_ALMOST_EMPTY field as set.
0x0 - CTLR_DESC_FIFO_ALMOST_EMPTY interrupt disabled
0x1 - CTLR_DESC_FIFO_ALMOST_EMPTY interrupt enabled
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Controller Receive FIFO Fill Threshold Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_RX_FIFO_FILL_THRESHOLD field as set.
0x0 - CTLR_RX_FIFO_FILL_THRESHOLD interrupt disabled
0x1 - CTLR_RX_FIFO_FILL_THRESHOLD interrupt enabled
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_EMPTY</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Empty Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_DESC_FIFO_EMPTY field as set.
0x0 - CTLR_DESC_FIFO_EMPTY interrupt disabled
0x1 - CTLR_DESC_FIFO_EMPTY interrupt enabled
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DONE</spirit:name>
            <spirit:displayName>CTLR_DONE</spirit:displayName>
            <spirit:description>Controller Done Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_DONE field as set.
0x0 - CTLR_DONE interrupt disabled
0x1 - CTLR_DONE interrupt enabled
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_PEC_ERROR</spirit:name>
            <spirit:displayName>CTLR_PEC_ERROR</spirit:displayName>
            <spirit:description>Controller PEC Error Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_PEC_ERROR field as set.
0x0 - CTLR_PEC_ERROR interrupt disabled
0x1 - CTLR_PEC_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_NACK_ERROR</spirit:name>
            <spirit:displayName>CTLR_NACK_ERROR</spirit:displayName>
            <spirit:description>Controller NACK Error Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_NACK_ERROR field as set.
0x0 - CTLR_NACK_ERROR interrupt disabled
0x1 - CTLR_NACK_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_LOA</spirit:name>
            <spirit:displayName>CTLR_LOA</spirit:displayName>
            <spirit:description>Controller Loss of Arbitration Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the CTLR_LOA field as set.
0x0 - CTLR_LOA interrupt disabled
0x1 - CTLR_LOA interrupt enabled
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_ALMOST_EMPTY</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Almost Empty Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_DESC_FIFO_ALMOST_EMPTY field as set.
0x0 - TGT_DESC_FIFO_ALMOST_EMPTY interrupt disabled
0x1 - TGT_DESC_FIFO_ALMOST_EMPTY interrupt enabled
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_WRITE</spirit:name>
            <spirit:displayName>TGT_WRITE</spirit:displayName>
            <spirit:description>Target Write Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_WRITE field as set.
0x0 - TGT_WRITE interrupt disabled
0x1 - TGT_WRITE interrupt enabled
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_READ</spirit:name>
            <spirit:displayName>TGT_READ</spirit:displayName>
            <spirit:description>Target Read Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_READ field as set.
0x0 - TGT_READ interrupt disabled
0x1 - TGT_READ interrupt enabled
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_FILL_THRESHOLD</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Target Receive FIFO Fill Threshold Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_RX_FIFO_FILL_THRESHOLD field as set.
0x0 - TGT_RX_FIFO_FILL_THRESHOLD interrupt disabled
0x1 - TGT_RX_FIFO_FILL_THRESHOLD interrupt enabled
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_EMPTY</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Empty Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_DESC_FIFO_EMPTY field as set.
0x0 - TGT_DESC_FIFO_EMPTY interrupt disabled
0x1 - TGT_DESC_FIFO_EMPTY interrupt enabled
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DONE</spirit:name>
            <spirit:displayName>TGT_DONE</spirit:displayName>
            <spirit:description>Target Done Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_DONE field as set.
0x0 - TGT_DONE interrupt disabled
0x1 - TGT_DONE interrupt enabled
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_PEC_ERROR</spirit:name>
            <spirit:displayName>TGT_PEC_ERROR</spirit:displayName>
            <spirit:description>Target PEC Error Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_PEC_ERROR field as set.
0x0 - TGT_PEC_ERROR interrupt disabled
0x1 - TGT_PEC_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_LOA</spirit:name>
            <spirit:displayName>TGT_LOA</spirit:displayName>
            <spirit:description>Target Loss of Arbitration Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the TGT_LOA field as set.
0x0 - TGT_LOA interrupt disabled
0x1 - TGT_LOA interrupt enabled
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERROR_IRQ</spirit:name>
            <spirit:displayName>ERROR_IRQ</spirit:displayName>
            <spirit:description>Error Interrupt Enable
When set, an interrupt will be generated when the IRQ_ISR register reports the ERROR_IRQ field as set.
0x0 - ERROR_IRQ interrupt disabled
0x1 - ERROR_IRQ interrupt enabled
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IRQ_ISR</spirit:name>
          <spirit:displayName>IRQ_ISR</spirit:displayName>
          <spirit:description>Interrupt Status Register</spirit:description>
          <spirit:addressOffset>0x028</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_ALMOST_EMPTY</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Almost Empty Interrupt Status
Set when the Controller has detected only one descriptor in the Descriptor FIFO and a transaction is in progress.
0x0 - Controller Descriptor FIFO contains more than one descriptor or no transaction in progress
0x1 - Controller Descriptor FIFO only contains one descriptor and a transaction is in progress
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Controller Receive FIFO Fill Threshold Interrupt Status
Set when the Controller Receive FIFO has reached the fill level configured in the CTLR_RX_FIFO_FILL_THRESHOLD register.
0x0 - Controller Receive FIFO fill level below configured threshold
0x1 - Controller Receive FIFO has reached the configured fill threshold
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_EMPTY</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Empty Interrupt Status
Set when the Controller has detected the Descriptor FIFO is empty and another descriptor is required.
0x0 - Controller Descriptor FIFO not empty or descriptor not required
0x1 - Controller Descriptor FIFO empty and a descriptor is required
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DONE</spirit:name>
            <spirit:displayName>CTLR_DONE</spirit:displayName>
            <spirit:description>Controller Done Interrupt Status
Set when the Controller has successfully completed the transaction.
0x0 - Controller transaction not complete or no transaction in progress
0x1 - Controller transaction is complete
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_PEC_ERROR</spirit:name>
            <spirit:displayName>CTLR_PEC_ERROR</spirit:displayName>
            <spirit:description>Controller PEC Error Interrupt Status
Set when the Controller has detected a PEC error during a Read transaction with PEC enabled.
0x0 - No PEC error
0x1 - PEC error detected during Read
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_NACK_ERROR</spirit:name>
            <spirit:displayName>CTLR_NACK_ERROR</spirit:displayName>
            <spirit:description>Controller NACK Error Interrupt Status
Set when the Controller has received a NACK response from the Target following transmission of a byte as Controller-transmitter.
0x0 - No NACK response from Target
0x1 - Target responded with NACK
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_LOA</spirit:name>
            <spirit:displayName>CTLR_LOA</spirit:displayName>
            <spirit:description>Controller Loss of Arbitration Interrupt Status
Set when the Controller has detected loss of arbitration as a Controller-transmitter.
0x0 -Â No loss of arbitration detected
0x1 - Loss of arbitration detected
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_ALMOST_EMPTY</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Almost Empty Interrupt Status
Set when the Target has detected only one descriptor in the Descriptor FIFO and a transaction is in progress
0x0 - Target Descriptor FIFO contains more than one descriptor or no transaction in progress
0x1 - Target Descriptor FIFO only contains one descriptor and a transaction is in progress
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_WRITE</spirit:name>
            <spirit:displayName>TGT_WRITE</spirit:displayName>
            <spirit:description>Target Write Interrupt Status
Set when the Target has detected a start of write transaction for a Target device enabled in TGT_CONTROL_[7:0]
0x0 - No write detected matching an enabled target device
0x1 - Start of write detected matching an enabled target device, details available in TGT_STATUS
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_READ</spirit:name>
            <spirit:displayName>TGT_READ</spirit:displayName>
            <spirit:description>Target Read Interrupt Status
Set when the Target has detected a start of read transaction for a Target device enabled in TGT_CONTROL_[7:0]
0x0 - No read detected matching an enabled target device
0x1 - Start of read detected matching an enabled target device, details available in TGT_STATUS
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_FILL_THRESHOLD</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Target Receive FIFO Fill Threshold Interrupt Status
Set when the Target Receive FIFO has reached the fill level configured in the TGT_RX_FIFO_FILL_THRESHOLD register
0x0 - Target Receive FIFO fill level below configured threshold
0x1 - Target Receive FIFO has reached the configured fill threshold
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_EMPTY</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Empty Interrupt Status
Set when the Target has detected the Descriptor FIFO is empty and another descriptor is required
0x0 - Target Descriptor FIFO not empty or descriptor not required
0x1 - Target Descriptor FIFO empty and a descriptor is required
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DONE</spirit:name>
            <spirit:displayName>TGT_DONE</spirit:displayName>
            <spirit:description>Target Done Interrupt Status
Target has detected a STOP condition, transaction is complete and no PEC error detected (if write, if applicable)
0x0 - Target transaction not done
0x1 - Target transaction done
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_PEC_ERROR</spirit:name>
            <spirit:displayName>TGT_PEC_ERROR</spirit:displayName>
            <spirit:description>Target PEC Error Interrupt Status
Set when the Target has detected a STOP condition, transaction is complete but PEC error detected (only applicable to Writes)
0x0 - Target transaction not done
0x1 - Target transaction done, but PEC error detected
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_LOA</spirit:name>
            <spirit:displayName>TGT_LOA</spirit:displayName>
            <spirit:description>Target Loss of Arbitration Interrupt Status
When set the Target has detected loss of arbitration as a Target-transmitter
0x0 - No loss of arbitration detected
0x1 - Loss of arbitration detected
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ERROR_IRQ</spirit:name>
            <spirit:displayName>ERROR_IRQ</spirit:displayName>
            <spirit:description>Error Interrupt Status
Set when an error condition has occurred that is both enabled in the ERR_IRQ_IER register and set in the ERR_IRQ_ISR register.
0x0 - No error condition detected
0x1 - Error condition detected
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ERR_IRQ_IER</spirit:name>
          <spirit:displayName>ERR_IRQ_IER</spirit:displayName>
          <spirit:description>Error Interrupt Enable Register</spirit:description>
          <spirit:addressOffset>0x02C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>PHY_CTLR_CEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_CTLR_CEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY CEXT Timeout Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_CTLR_CEXT_TIMEOUT field as set.
0x0 - PHY_CTLR_CEXT_TIMEOUT interrupt disabled
0x1 - PHY_CTLR_CEXT_TIMEOUT interrupt enabled
</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_CTLR_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_CTLR_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY TEXT Timeout Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_CTLR_TEXT_TIMEOUT field as set.
0x0 - PHY_CTLR_TEXT_TIMEOUT interrupt disabled
0x1 - PHY_CTLR_TEXT_TIMEOUT interrupt enabled
</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_ERROR</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_ERROR</spirit:displayName>
            <spirit:description>Controller Receive FIFO Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_RX_FIFO_ERROR field as set.
0x0 - CTLR_RX_FIFO_ERROR interrupt disabled
0x1 - CTLR_RX_FIFO_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Controller Receive FIFO Overflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_RX_FIFO_OVERFLOW field as set.
0x0 - CTLR_RX_FIFO_OVERFLOW interrupt disabled
0x1 - CTLR_RX_FIFO_OVERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Controller Receive FIFO Underflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_RX_FIFO_UNDERFLOW field as set.
0x0 - CTLR_RX_FIFO_UNDERFLOW interrupt disabled
0x1 - CTLR_RX_FIFO_UNDERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_ERROR</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_ERROR</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_DESC_FIFO_ERROR field as set.
0x0 - CTLR_DESC_FIFO_ERROR interrupt disabled
0x1 - CTLR_DESC_FIFO_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Overflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_DESC_FIFO_OVERFLOW field as set.
0x0 - CTLR_DESC_FIFO_OVERFLOW interrupt disabled
0x1 - CTLR_DESC_FIFO_OVERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Underflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_DESC_FIFO_UNDERFLOW field as set.
0x0 - CTLR_DESC_FIFO_UNDERFLOW interrupt disabled
0x1 - CTLR_DESC_FIFO_UNDERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_ERROR</spirit:name>
            <spirit:displayName>CTLR_DESC_ERROR</spirit:displayName>
            <spirit:description>Controller Descriptor Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the CTLR_DESC_ERROR field as set.
0x0 - CTLR_DESC_ERROR interrupt disabled
0x1 - CTLR_DESC_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_TGT_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_TGT_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Target PHY TEXT Timeout Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_TGT_TEXT_TIMEOUT field as set.
0x0 - PHY_TGT_TEXT_TIMEOUT interrupt disabled
0x1 - PHY_TGT_TEXT_TIMEOUT interrupt enabled
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_ERROR</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_ERROR</spirit:displayName>
            <spirit:description>Target Receive FIFO Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_RX_FIFO_ERROR field as set.
0x0 - TGT_RX_FIFO_ERROR interrupt disabled
0x1 - TGT_RX_FIFO_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Target Receive FIFO Overflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_RX_FIFO_OVERFLOW field as set.
0x0 - TGT_RX_FIFO_OVERFLOW interrupt disabled
0x1 - TGT_RX_FIFO_OVERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Target Receive FIFO Underflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_RX_FIFO_UNDERFLOW field as set.
0x0 - TGT_RX_FIFO_UNDERFLOW interrupt disabled
0x1 - TGT_RX_FIFO_UNDERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_ERROR</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_ERROR</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_DESC_FIFO_ERROR field as set.
0x0 - TGT_DESC_FIFO_ERROR interrupt disabled
0x1 - TGT_DESC_FIFO_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Overflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_DESC_FIFO_OVERFLOW field as set.
0x0 - TGT_DESC_FIFO_OVERFLOW interrupt disabled
0x1 - TGT_DESC_FIFO_OVERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Underflow Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_DESC_FIFO_UNDERFLOW field as set.
0x0 - TGT_DESC_FIFO_UNDERFLOW interrupt disabled
0x1 - TGT_DESC_FIFO_UNDERFLOW interrupt enabled
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_ERROR</spirit:name>
            <spirit:displayName>TGT_DESC_ERROR</spirit:displayName>
            <spirit:description>Target Descriptor Error Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the TGT_DESC_ERROR field as set.
0x0 - TGT_DESC_ERROR interrupt disabled
0x1 - TGT_DESC_ERROR interrupt enabled
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_UNEXPTD_BUS_IDLE</spirit:name>
            <spirit:displayName>PHY_UNEXPTD_BUS_IDLE</spirit:displayName>
            <spirit:description>PHY Unexpected Bus Idle Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_UNEXPTD_BUS_IDLE field as set.
0x0 - PHY_UNEXPTD_BUS_IDLE interrupt disabled
0x1 - PHY_UNEXPTD_BUS_IDLE interrupt enabled
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_SMBDAT_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_SMBDAT_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>PHY SMBDAT Low Timeout Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_SMBDAT_LOW_TIMEOUT field as set.
0x0 - PHY_SMBDAT_LOW_TIMEOUT interrupt disabled
0x1 - PHY_SMBDAT_LOW_TIMEOUT interrupt enabled
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_SMBCLK_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_SMBCLK_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>PHY SMBCLK Low Timeout Interrupt Enable
When set, an interrupt will be generated when the ERR_IRQ_ISR register reports the PHY_SMBCLK_LOW_TIMEOUT field as set.
0x0 - PHY_SMBCLK_LOW_TIMEOUT interrupt disabled
0x1 - PHY_SMBCLK_LOW_TIMEOUT interrupt enabled
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ERR_IRQ_ISR</spirit:name>
          <spirit:displayName>ERR_IRQ_ISR</spirit:displayName>
          <spirit:description>Error Interrupt Status Register</spirit:description>
          <spirit:addressOffset>0x030</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>PHY_CTLR_CEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_CTLR_CEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY CEXT Timeout Interrupt Status
Set when the Controller PHY has detected SMBCLK stretching performed by the Controller function beyond the threshold configured in the PHY_CTLR_CEXT_TIMEOUT register.
0x0 - Controller function clock stretching has not exceeded threshold
0x1 - Controller function clock stretching has exceeded the threshold
</spirit:description>
            <spirit:bitOffset>19</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_CTLR_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_CTLR_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY TEXT Timeout Interrupt Status
Set when the Controller has detected SMBCLK stretching performed by an external Target beyond the threshold configured in the PHY_CTLR_TEXT_TIMEOUT register.
0x0 - Controller function has not detected Target clock stretching that exceeds the threshold
0x1 - Controller function has detected Target clock stretching that exceeds the threshold
</spirit:description>
            <spirit:bitOffset>18</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_ERROR</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_ERROR</spirit:displayName>
            <spirit:description>Controller Receive FIFO Error Interrupt Status
Set when the Controller has detected that an attempt to read or write to the Receive FIFO while it is in reset has been made.
0x0 - No Receive FIFO read/write error detected
0x1 - Receive FIFO read/write error detected
</spirit:description>
            <spirit:bitOffset>17</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Controller Receive FIFO Overflow Interrupt Status
Set when the Controller has detected the Receive FIFO has overflowed.
0x0 - No Receive FIFO overflow detected
0x1 - Receive FIFO overflow detected
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_RX_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>CTLR_RX_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Controller Receive FIFO Underflow Interrupt Status
Set when the Controller has detected the Receive FIFO has underflowed.
0x0 - No Receive FIFO underflow detected
0x1 - Receive FIFO underflow detected
</spirit:description>
            <spirit:bitOffset>15</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_ERROR</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_ERROR</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Error Interrupt Status
Set when the Controller has detected that an attempt to write to the Descriptor FIFO while it is in reset has been made.
0x0 - No Descriptor FIFO write error detected
0x1 - Descriptor FIFO write error detected
</spirit:description>
            <spirit:bitOffset>14</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Overflow Interrupt Status
Set when the Controller has detected the Descriptor FIFO has overflowed.
0x0 - No Descriptor FIFO overflow detected
0x1 - Descriptor FIFO overflow detected
</spirit:description>
            <spirit:bitOffset>13</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>CTLR_DESC_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Underflow Interrupt Status
Set when the Controller has detected the Descriptor FIFO has underflowed.
0x0 - No Descriptor FIFO underflow detected
0x1 - Descriptor FIFO underflow detected
</spirit:description>
            <spirit:bitOffset>12</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>CTLR_DESC_ERROR</spirit:name>
            <spirit:displayName>CTLR_DESC_ERROR</spirit:displayName>
            <spirit:description>Controller Descriptor Error Interrupt Status
Set when the Controller has received an invalid descriptor ID via the Descriptor FIFO or the first descriptor in the sequence is not a START descriptor.
0x0 - No descriptor error detected
0x1 - Descriptor error detected
</spirit:description>
            <spirit:bitOffset>11</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_TGT_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_TGT_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Target PHY TEXT Timeout Interrupt Status
Set when the PHY has detected SMBCLK stretching performed by the Target function beyond the threshold configured in the PHY_TGT_TEXT_TIMEOUT register.
0x0 - Target function clock stretching has not exceeded threshold
0x1 - Target function clock stretching has exceeded the threshold
</spirit:description>
            <spirit:bitOffset>10</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_ERROR</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_ERROR</spirit:displayName>
            <spirit:description>Target Receive FIFO Error Interrupt Status
Set when the Target has detected that an attempt to read or write to the Receive FIFO whilst it is in reset has been made.
0x0 - No Receive FIFO read/write error detected
0x1 - Receive FIFO read/write error detected
</spirit:description>
            <spirit:bitOffset>9</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Target Receive FIFO Overflow Interrupt Status
Set when the Target has detected the Receive FIFO has overflowed
0x0 - No Receive FIFO overflow detected
0x1 - Receive FIFO overflow detected
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_RX_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>TGT_RX_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Target Receive FIFO Underflow Interrupt Status
Set when the Target has detected the Receive FIFO has underflowed
0x0 - No Receive FIFO underflow detected
0x1 - Receive FIFO underflow detected
</spirit:description>
            <spirit:bitOffset>7</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_ERROR</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_ERROR</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Error Interrupt Status
Set when the Target has detected that an attempt to write to the Descriptor FIFO whilst it is in reset has been made.
0x0 - No Descriptor FIFO write error detected
0x1 - Descriptor FIFO write error detected
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_OVERFLOW</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_OVERFLOW</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Overflow Interrupt Status
Set when the Target has detected the Descriptor FIFO has overflowed
0x0 - No Descriptor FIFO overflow detected
0x1 - Descriptor FIFO overflow detected
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_FIFO_UNDERFLOW</spirit:name>
            <spirit:displayName>TGT_DESC_FIFO_UNDERFLOW</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Underflow Interrupt Status
Set when the Target has detected the Descriptor FIFO has underflowed
0x0 - No Descriptor FIFO underflow detected
0x1 - Descriptor FIFO underflow detected
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TGT_DESC_ERROR</spirit:name>
            <spirit:displayName>TGT_DESC_ERROR</spirit:displayName>
            <spirit:description>Target Descriptor Error Interrupt Status
Set when the Target has received an invalid descriptor via the Descriptor FIFO.
This is asserted when either an undefined descriptor ID or unexpected type (e.g. read descriptor during a write) is received.
0x0 - No descriptor error detected
0x1 - Descriptor error detected
</spirit:description>
            <spirit:bitOffset>3</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_UNEXPTD_BUS_IDLE</spirit:name>
            <spirit:displayName>PHY_UNEXPTD_BUS_IDLE</spirit:displayName>
            <spirit:description>PHY Unexpected Bus Idle Interrupt Status
Set when the PHY has detected an unexpected bus idle condition by observing SMBCLK/SMBDAT inputs high beyond the threshold configured in the PHY_IDLE_THRESHOLD register, whilst a transaction is in progress (i.e. no STOP condition).
0x0 - No unexpected bus idle detected
0x1 - Unexpected bus idle condition detected
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_SMBDAT_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_SMBDAT_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>PHY SMBDAT Low Timeout Interrupt Status
Set when the PHY has detected SMBDAT persistently low following a rising edge on SMBCLK for the timeout value configured in the PHY_TIMEOUT_MAX register.
0x0 - No SMBDAT low timeout
0x1 - SMBDAT low timeout detected
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PHY_SMBCLK_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>PHY_SMBCLK_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>PHY SMBCLK Low Timeout Interrupt Status
Set when the PHY has detected SMBCLK persistently low for the timeout value configured in the PHY_TIMEOUT_MIN register.
0x0 - No SMBCLK low timeout
0x1 - SMBCLK low timeout detected
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>IRQ_ISR_FORCE</spirit:name>
          <spirit:displayName>IRQ_ISR_FORCE</spirit:displayName>
          <spirit:description>Debug IRQ ISR Force Control Register</spirit:description>
          <spirit:addressOffset>0x034</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>IRQ_ISR_FORCE</spirit:name>
            <spirit:displayName>IRQ_ISR_FORCE</spirit:displayName>
            <spirit:description>Debug IRQ ISR Force
Debug - When set, the equivalent bit in the IRQ_ISR register is set to &apos;1&apos; in order to force assertion of the interrupt source.
0x0 - No forced assertion of the equivalent bit in IRQ_ISR register
0x1 - Equivalent bit in the IRQ_ISR register is forced to &apos;1&apos;
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>16</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>ERR_IRQ_ISR_FORCE</spirit:name>
          <spirit:displayName>ERR_IRQ_ISR_FORCE</spirit:displayName>
          <spirit:description>Debug Error IRQ ISR Force Control Register</spirit:description>
          <spirit:addressOffset>0x038</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ERR_IRQ_ISR_FORCE</spirit:name>
            <spirit:displayName>ERR_IRQ_ISR_FORCE</spirit:displayName>
            <spirit:description>Debug Error IRQ ISR Force
Debug - When set, the equivalent bit in the ERR_IRQ_ISR register is set to &apos;1&apos; in order to force assertion of the interrupt source.
0x0 - No forced assertion of the equivalent bit in ERR_IRQ_ISR register
0x1 - Equivalent bit in the ERR_IRQ_ISR register is forced to &apos;1&apos;
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>20</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_STATUS</spirit:name>
          <spirit:displayName>PHY_STATUS</spirit:displayName>
          <spirit:description>PHY Status Register</spirit:description>
          <spirit:addressOffset>0x200</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SMBDAT_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>SMBDAT_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>SMBDAT Low Timeout Status
Indicates when the SMBus PHY has detected a SMBDAT low timeout in accordance with the threshold configured in the PHY_TIMEOUT_MAX register.
0x0 - SMBDAT low timeout not detected
0x1 - SMBDAT low timeout detected
</spirit:description>
            <spirit:bitOffset>2</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SMBCLK_LOW_TIMEOUT</spirit:name>
            <spirit:displayName>SMBCLK_LOW_TIMEOUT</spirit:displayName>
            <spirit:description>SMBCLK Low Timeout Status
Indicates when the SMBus PHY has detected a SMBCLK low timeout in accordance with the threshold configured in the PHY_TIMEOUT_MIN register.
0x0 - SMBCLK low timeout not detected
0x1 - SMBCLK low timeout detected
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>BUS_IDLE</spirit:name>
            <spirit:displayName>BUS_IDLE</spirit:displayName>
            <spirit:description>Bus Idle Status
Indicates when the SMBus PHY has detected the Bus Idle condition
0x0 - Bus Idle condition not detected
0x1 - Bus is Idle
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_FILTER_CONTROL</spirit:name>
          <spirit:displayName>PHY_FILTER_CONTROL</spirit:displayName>
          <spirit:description>PHY Filter Control Register</spirit:description>
          <spirit:addressOffset>0x204</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x80000000</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Input Glitch Filter Enable
Enable the SMBCLK/SMBDAT input glitch filter
0x0 - Input glitch filter disabled
0x1 - Input glitch filter enabled
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DURATION</spirit:name>
            <spirit:displayName>DURATION</spirit:displayName>
            <spirit:description>Input Glitch Filter Duration
Configure the duration that the SMBCLK or SMBDAT inputs must be stable for before registering as a change in state.
This value is calculated as Time = s_axi_aclk period x (DURATION + 1)
This value must be configured to meet tSPIKE:MAX in accordance with the SMBus Specification.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>5</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_BUS_FREE_TIME</spirit:name>
          <spirit:displayName>PHY_BUS_FREE_TIME</spirit:displayName>
          <spirit:description>PHY Bus Free Time Control Register</spirit:description>
          <spirit:addressOffset>0x208</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>BUS_FREE_TIME</spirit:name>
            <spirit:displayName>BUS_FREE_TIME</spirit:displayName>
            <spirit:description>Bus Free Time Control
Configure the amount of time to wait following detection of a STOP condition before declaring a bus idle condition.
This value is calculated as Time = s_axi_aclk period x (BUS_FREE_TIME + 1)
This value must be configured to meet tBUF:MIN in accordance with the SMBus Specification.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_IDLE_THRESHOLD</spirit:name>
          <spirit:displayName>PHY_IDLE_THRESHOLD</spirit:displayName>
          <spirit:description>PHY Idle Threshold Control Register</spirit:description>
          <spirit:addressOffset>0x20C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>IDLE_THRESHOLD</spirit:name>
            <spirit:displayName>IDLE_THRESHOLD</spirit:displayName>
            <spirit:description>Bus Idle Time Control
Configure the amount of time that both SMBCLK and SMBDAT must be high before declaring a bus idle condition.
This value is calculated as Time = s_axi_aclk period x (IDLE_THRESHOLD + 1)
This value must be configured to meet tHIGH:MAX in accordance with the SMBus Specification.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TIMEOUT_PRESCALER</spirit:name>
          <spirit:displayName>PHY_TIMEOUT_PRESCALER</spirit:displayName>
          <spirit:description>PHY Timeout Prescaler Control Register</spirit:description>
          <spirit:addressOffset>0x210</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TIMEOUT_PRESCALER</spirit:name>
            <spirit:displayName>TIMEOUT_PRESCALER</spirit:displayName>
            <spirit:description>Timeout Prescaler Configuration
Configure the amount of time to wait before incrementing either the PHY_TIMEOUT_MIN or PHY_TIMEOUT_MAX counters.
This value is calculated as Prescaler_Time = s_axi_aclk period x (TIMEOUT_PRESCALER + 1)
The Prescaler_Time should be configured for 10us in order to stay within range of the PHY_TIMEOUT_MIN and PHY_TIMEOUT_MAX counters.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>13</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TIMEOUT_MIN</spirit:name>
          <spirit:displayName>PHY_TIMEOUT_MIN</spirit:displayName>
          <spirit:description>PHY Minimum Timeout Control Register</spirit:description>
          <spirit:addressOffset>0x214</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TIMEOUT_ENABLE</spirit:name>
            <spirit:displayName>TIMEOUT_ENABLE</spirit:displayName>
            <spirit:description>Minimum Timeout Detection Enable
Enable/disable the SMBCLK low timeout detection and subsequent consequent actions.
0x0 - SMBCLK low timeout detection disabled
0x1 - SMBCLK low timeout detection enabled
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>TIMEOUT_MIN</spirit:name>
            <spirit:displayName>TIMEOUT_MIN</spirit:displayName>
            <spirit:description>Minimum Timeout Configuration
Configure the threshold used to detect a SMBCLK low timeout and trigger the PHY_SMBCLK_TIMEOUT interrupt.
This value must be configured to meet tTIMEOUT:MIN in accordance with the SMBus Specification.
This value is calculated as Timeout_Min_Time = ((TIMEOUT_MIN + 1) x Prescaler_Time) - Prescaler_Time
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TIMEOUT_MAX</spirit:name>
          <spirit:displayName>PHY_TIMEOUT_MAX</spirit:displayName>
          <spirit:description>PHY Maximum Timeout Control Register</spirit:description>
          <spirit:addressOffset>0x218</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TIMEOUT_MAX</spirit:name>
            <spirit:displayName>TIMEOUT_MAX</spirit:displayName>
            <spirit:description>Maximum Timeout Configuration
Configure the threshold used to detect a SMBDAT low timeout and trigger the PHY_SMBDAT_TIMEOUT interrupt.
This value must be configured to meet tTIMEOUT:MAX in accordance with the SMBus Specification.
This value is calculated as Timeout_Max_Time = ((TIMEOUT_MAX + 1) x Prescaler_Time) - Prescaler_Time
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_RESET_CONTROL</spirit:name>
          <spirit:displayName>PHY_RESET_CONTROL</spirit:displayName>
          <spirit:description>PHY Reset Control Register</spirit:description>
          <spirit:addressOffset>0x21C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>SMBCLK_FORCE_TIMEOUT</spirit:name>
            <spirit:displayName>SMBCLK_FORCE_TIMEOUT</spirit:displayName>
            <spirit:description>SMBCLK Timeout Force Control
Override the SMBCLK low detection to force assertion of this timeout and subsequent consequent actions.
0x0 - No SMBCLK low timeout forced assertion
0x1 - Force assertion of the SMBCLK low timeout and subsequent consequent actions
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>SMBCLK_FORCE_LOW</spirit:name>
            <spirit:displayName>SMBCLK_FORCE_LOW</spirit:displayName>
            <spirit:description>SMBCLK Output Force Control
Override the PHY control of the SMBCLK and force the output low.
0xCFB = SMBCLK force low
Any other value = SMBCLK under PHY control
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>12</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_DATA_SETUP</spirit:name>
          <spirit:displayName>PHY_TGT_DATA_SETUP</spirit:displayName>
          <spirit:description>Target PHY Data Setup Control Register</spirit:description>
          <spirit:addressOffset>0x400</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TGT_DATA_SETUP</spirit:name>
            <spirit:displayName>TGT_DATA_SETUP</spirit:displayName>
            <spirit:description>Target PHY Data Setup
Configure the data setup time when operating as a Target-transmitter post clock stretching.
This value must be configured to meet tSU:DAT:Min in accordance with the SMBus Specification and account for tR:Max/tF:Max.
This value is calculated as Setup Time = s_axi_aclk period x (TGT_DATA_SETUP + 1)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_TEXT_PRESCALER</spirit:name>
          <spirit:displayName>PHY_TGT_TEXT_PRESCALER</spirit:displayName>
          <spirit:description>Target PHY TEXT Timeout Prescaler Configuration Register</spirit:description>
          <spirit:addressOffset>0x404</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TGT_TEXT_PRESCALER</spirit:name>
            <spirit:displayName>TGT_TEXT_PRESCALER</spirit:displayName>
            <spirit:description>Target PHY TEXT Timeout Prescaler Configuration
Configure the amount of time to measure before incrementing the PHY_TGT_TEXT_TIMEOUT counter when SMBCLK stretching is active within the Target function.
This value is calculated as Text_Prescaler_Time = s_axi_aclk period x (TGT_TEXT_PRESCALER+ 1)
The Text_Prescaler_Time should be configured for 1us in order to stay within range of the PHY_TGT_TEXT_TIMEOUT counter.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_TEXT_TIMEOUT</spirit:name>
          <spirit:displayName>PHY_TGT_TEXT_TIMEOUT</spirit:displayName>
          <spirit:description>Target PHY TEXT Timeout Configuration Register</spirit:description>
          <spirit:addressOffset>0x408</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TGT_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>TGT_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Target PHY TEXT Timeout Configuration
Configure the threshold used to detect that the Target function has exceeded the cumulative clock stretching threshold and trigger the TGT_TEXT_TIMEOUT interrupt.
This value must be configured to meet tLOW:TEXT in accordance with the SMBus Specification.
This value is calculated as Text_Timeout_Time = TGT_TEXT_TIMEOUT x Text_Prescaler_Time
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_TEXT_MAX</spirit:name>
          <spirit:displayName>PHY_TGT_TEXT_MAX</spirit:displayName>
          <spirit:description>Target PHY TEXT Timeout Max Status Register</spirit:description>
          <spirit:addressOffset>0x40C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TGT_TEXT_MAX</spirit:name>
            <spirit:displayName>TGT_TEXT_MAX</spirit:displayName>
            <spirit:description>Target PHY TEXT Timeout Max
Indicates the maximum amount of cumulative time in Text_Prescaler_Time units that the Target function has spent performing SMBCLK stretching during any single transaction (between an initial START and a STOP).
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>clear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_DBG_STATE</spirit:name>
          <spirit:displayName>PHY_TGT_DBG_STATE</spirit:displayName>
          <spirit:description>Target PHY Debug State Register</spirit:description>
          <spirit:addressOffset>0x410</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DBG_STATE</spirit:name>
            <spirit:displayName>DBG_STATE</spirit:displayName>
            <spirit:description>Target PHY Debug State
Reports the current Target PHY FSM State to assist with debug.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_TGT_DATA_HOLD</spirit:name>
          <spirit:displayName>PHY_TGT_DATA_HOLD</spirit:displayName>
          <spirit:description>Target PHY Data Hold Control Register</spirit:description>
          <spirit:addressOffset>0x414</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>TGT_DATA_HOLD</spirit:name>
            <spirit:displayName>TGT_DATA_HOLD</spirit:displayName>
            <spirit:description>Target PHY Data Hold
Configure the data hold time when operating as a Target-transmitter.
This value must be configured to meet tSU:DAT:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Hold Time = s_axi_aclk period x (TGT_DATA_HOLD + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Hold Time = s_axi_aclk period x (TGT_DATA_HOLD + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>10</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_STATUS</spirit:name>
          <spirit:displayName>TGT_STATUS</spirit:displayName>
          <spirit:description>Target Status Register</spirit:description>
          <spirit:addressOffset>0x600</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ACTIVE</spirit:name>
            <spirit:displayName>ACTIVE</spirit:displayName>
            <spirit:description>Target Active Status
Indicates that the Target function has received a transaction that matches an enabled address in TGT_CONTROL_[7:0]
0x0 - No active transaction in progress
0x1 - Active Target transaction in progress
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Address Status
Target address for the current transaction, only valid when ACTIVE = 0x1
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RW</spirit:name>
            <spirit:displayName>RW</spirit:displayName>
            <spirit:description>Target Read/Write Status
Indicates the current transaction type, only valid when ACTIVE = 0x1
0x0 = Write transaction
0x1 = Read transaction
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_DESC_FIFO</spirit:name>
          <spirit:displayName>TGT_DESC_FIFO</spirit:displayName>
          <spirit:description>Target Descriptor FIFO Control Register
Writing to this register pushes the value into the Target Descriptor FIFO
</spirit:description>
          <spirit:addressOffset>0x604</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Target Descriptor ID. Valid IDs are as follows -
0x0 - TARGET_WRITE_ACK
0x1 - TARGET_WRITE_NACK
0x2 - TARGET_WRITE_PEC
0x8 - TARGET_READ
0x9 - TARGET_READ_PEC
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAYLOAD</spirit:name>
            <spirit:displayName>PAYLOAD</spirit:displayName>
            <spirit:description>Target Descriptor Payload
Data payload for transmission as a Target-transmitter.
Valid only when ID = 0x8 (TARGET_READ).
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_DESC_STATUS</spirit:name>
          <spirit:displayName>TGT_DESC_STATUS</spirit:displayName>
          <spirit:description>Target Descriptor FIFO Status Register</spirit:description>
          <spirit:addressOffset>0x608</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FILL_LEVEL</spirit:name>
            <spirit:displayName>FILL_LEVEL</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Fill Level Status
Indicates the current fill level of the Target Descriptor FIFO.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FULL</spirit:name>
            <spirit:displayName>FULL</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Full Status
Indicates if the Target Descriptor FIFO is full
0x0 - FIFO not full
0x1 - FIFO full
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_FULL</spirit:name>
            <spirit:displayName>ALMOST_FULL</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Almost Full Status
Indicates if the Target Descriptor FIFO is almost full
0x0 - FIFO has space for more than one descriptor
0x1 - FIFO only has space for one more descriptor
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_EMPTY</spirit:name>
            <spirit:displayName>ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Almost Empty Status
Indicates if the Target Descriptor FIFO is almost empty
0x0 - FIFO contains more than one descriptor
0x1 - FIFO contains one descriptor or less
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EMPTY</spirit:name>
            <spirit:displayName>EMPTY</spirit:displayName>
            <spirit:description>Target Descriptor FIFO Empty Status
Indicates if the Target Descriptor FIFO is empty
0x0 - FIFO not empty
0x1 - FIFO empty
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_RX_FIFO</spirit:name>
          <spirit:displayName>TGT_RX_FIFO</spirit:displayName>
          <spirit:description>Target Receive FIFO Register</spirit:description>
          <spirit:addressOffset>0x60C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RESET</spirit:name>
            <spirit:displayName>RESET</spirit:displayName>
            <spirit:description>Target Receive FIFO Reset Control
When set the Target Receive FIFO is reset to a known state.
Poll the RESET_BUSY field in the TGT_RX_FIFO_STATUS register to determine when the reset is complete.
0x0 - FIFO not reset
0x1 - Reset FIFO
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAYLOAD</spirit:name>
            <spirit:displayName>PAYLOAD</spirit:displayName>
            <spirit:description>Target Receive Payload Byte
Reading this register pops a value from the Target Receive FIFO.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:readAction>modify</spirit:readAction>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_RX_FIFO_STATUS</spirit:name>
          <spirit:displayName>TGT_RX_FIFO_STATUS</spirit:displayName>
          <spirit:description>Target Receive FIFO Status Register</spirit:description>
          <spirit:addressOffset>0x610</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>MAX_FILL_LEVEL</spirit:name>
            <spirit:displayName>MAX_FILL_LEVEL</spirit:displayName>
            <spirit:description>Target Receive FIFO Max Fill Level Status
Indicates the maximum recorded fill level of the Target Receive FIFO.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FILL_LEVEL</spirit:name>
            <spirit:displayName>FILL_LEVEL</spirit:displayName>
            <spirit:description>Target Receive FIFO Fill Level Status
Indicates the current fill level of the Target Receive FIFO.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESET_BUSY</spirit:name>
            <spirit:displayName>RESET_BUSY</spirit:displayName>
            <spirit:description>Target Receive FIFO Reset Busy Status
Indicates if the Target Receive FIFO is currently undergoing a reset and is unavailable for either read or write.
0x0 - FIFO not in reset
0x1 - FIFO reset in progress
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FULL</spirit:name>
            <spirit:displayName>FULL</spirit:displayName>
            <spirit:description>Target Receive FIFO Full Status
Indicates if the Target Receive FIFO is full
0x0 - FIFO not full
0x1 - FIFO full
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_FULL</spirit:name>
            <spirit:displayName>ALMOST_FULL</spirit:displayName>
            <spirit:description>Target Receive FIFO Almost Full Status
Indicates if the Target Receive FIFO is almost full
0x0 - FIFO has space for two or more bytes
0x1 - FIFO only has space for one more byte
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_EMPTY</spirit:name>
            <spirit:displayName>ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Target Receive FIFO Almost Empty Status
Indicates if the Target Receive FIFO is almost empty
0x0 - FIFO contains more than one byte
0x1 - FIFO contains one byte or less
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EMPTY</spirit:name>
            <spirit:displayName>EMPTY</spirit:displayName>
            <spirit:description>Target Receive FIFO Empty Status
Indicates if the Target Receive FIFO is empty
0x0 - FIFO not empty
0x1 - FIFO empty
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_RX_FIFO_FILL_THRESHOLD</spirit:name>
          <spirit:displayName>TGT_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
          <spirit:description>Target Receive FIFO Fill Threshold Control Register</spirit:description>
          <spirit:addressOffset>0x614</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FILL_THRESHOLD</spirit:name>
            <spirit:displayName>FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Target Receive FIFO Fill Threshold
Configure the Target Receive FIFO fill threshold that should trigger assertion of the TGT_RX_FIFO_FILL_THRESHOLD interrupt.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_DBG</spirit:name>
          <spirit:displayName>TGT_DBG</spirit:displayName>
          <spirit:description>Target Debug Register</spirit:description>
          <spirit:addressOffset>0x618</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FORCE_PEC_ERROR</spirit:name>
            <spirit:displayName>FORCE_PEC_ERROR</spirit:displayName>
            <spirit:description>Target Debug Force PEC Error
Corrupts the PEC byte generation/checking. When set, writes with PEC enabled will always report an error and the PEC byte transmitted during a read will be corrupted.
0x0 - PEC Error insertion disabled
0x1 - PEC Error insertion enabled
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DBG_STATE</spirit:name>
            <spirit:displayName>DBG_STATE</spirit:displayName>
            <spirit:description>Target Debug State
Reports the current Target FSM State to assist with debug.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_0</spirit:name>
          <spirit:displayName>TGT_CONTROL_0</spirit:displayName>
          <spirit:description>Target Device 0 Control Register</spirit:description>
          <spirit:addressOffset>0x620</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 0 Enable
Configure the enable for Target Device 0
0x0 - Target Device 0 disabled
0x1 - Target Device 0 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 0 Address
Configure the address for Device 0
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_1</spirit:name>
          <spirit:displayName>TGT_CONTROL_1</spirit:displayName>
          <spirit:description>Target Device 1 Control Register</spirit:description>
          <spirit:addressOffset>0x624</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 1 Enable
Configure the enable for Target Device 1
0x0 - Target Device 1 disabled
0x1 - Target Device 1 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 1 Address
Configure the address for Device 1
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_1" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 1)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_2</spirit:name>
          <spirit:displayName>TGT_CONTROL_2</spirit:displayName>
          <spirit:description>Target Device 2 Control Register</spirit:description>
          <spirit:addressOffset>0x628</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 2 Enable
Configure the enable for Target Device 2
0x0 - Target Device 2 disabled
0x1 - Target Device 2 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 2 Address
Configure the address for Device 2
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_2" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 2)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_3</spirit:name>
          <spirit:displayName>TGT_CONTROL_3</spirit:displayName>
          <spirit:description>Target Device 3 Control Register</spirit:description>
          <spirit:addressOffset>0x62C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 3 Enable
Configure the enable for Target Device 3
0x0 - Target Device 3 disabled
0x1 - Target Device 3 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 3 Address
Configure the address for Device 3
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_3" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 3)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_4</spirit:name>
          <spirit:displayName>TGT_CONTROL_4</spirit:displayName>
          <spirit:description>Target Device 4 Control Register</spirit:description>
          <spirit:addressOffset>0x630</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 4 Enable
Configure the enable for Target Device 4
0x0 - Target Device 4 disabled
0x1 - Target Device 4 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 4 Address
Configure the address for Device 4
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_4" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 4)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_5</spirit:name>
          <spirit:displayName>TGT_CONTROL_5</spirit:displayName>
          <spirit:description>Target Device 5 Control Register</spirit:description>
          <spirit:addressOffset>0x634</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 5 Enable
Configure the enable for Target Device 5
0x0 - Target Device 5 disabled
0x1 - Target Device 5 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 5 Address
Configure the address for Device 5
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_5" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 5)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_6</spirit:name>
          <spirit:displayName>TGT_CONTROL_6</spirit:displayName>
          <spirit:description>Target Device 6 Control Register</spirit:description>
          <spirit:addressOffset>0x638</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 6 Enable
Configure the enable for Target Device 6
0x0 - Target Device 6 disabled
0x1 - Target Device 6 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 6 Address
Configure the address for Device 6
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_6" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 6)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>TGT_CONTROL_7</spirit:name>
          <spirit:displayName>TGT_CONTROL_7</spirit:displayName>
          <spirit:description>Target Device 7 Control Register</spirit:description>
          <spirit:addressOffset>0x63C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Target Device 7 Enable
Configure the enable for Target Device 7
0x0 - Target Device 7 disabled
0x1 - Target Device 7 enabled, the IP will automatically ACK a transaction with an address matching ADDRESS
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ADDRESS</spirit:name>
            <spirit:displayName>ADDRESS</spirit:displayName>
            <spirit:description>Target Device 7 Address
Configure the address for Device 7
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:vendorExtensions>
            <xilinx:registerInfo>
              <xilinx:enablement>
                <xilinx:isEnabled xilinx:resolve="dependent" xilinx:id="REGISTER_ENABLEMENT.S_AXI.REG.TGT_CONTROL_7" xilinx:dependency="(spirit:decode(id(&apos;PARAM_VALUE.NUM_TARGET_DEVICES&apos;)) > 7)">true</xilinx:isEnabled>
              </xilinx:enablement>
            </xilinx:registerInfo>
          </spirit:vendorExtensions>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_DATA_HOLD</spirit:name>
          <spirit:displayName>PHY_CTLR_DATA_HOLD</spirit:displayName>
          <spirit:description>Controller PHY Data Setup Control Register</spirit:description>
          <spirit:addressOffset>0x800</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_DATA_HOLD</spirit:name>
            <spirit:displayName>CTLR_DATA_HOLD</spirit:displayName>
            <spirit:description>Controller PHY Data Hold
Configure the data hold time when operating as a Controller-transmitter.
This value must be configured to meet tHD:DAT:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Hold Time = s_axi_aclk period x (CTLR_DATA_HOLD + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Hold Time = s_axi_aclk period x (CTLR_DATA_HOLD + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_START_HOLD</spirit:name>
          <spirit:displayName>PHY_CTLR_START_HOLD</spirit:displayName>
          <spirit:description>Controller PHY Start Hold Control Register</spirit:description>
          <spirit:addressOffset>0x804</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_START_HOLD</spirit:name>
            <spirit:displayName>CTLR_START_HOLD</spirit:displayName>
            <spirit:description>Controller PHY Start Hold
Configure the START condition hold time.
This value must be configured to meet tHD:STA:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Hold Time = s_axi_aclk period x (CTLR_START_HOLD + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Hold Time = s_axi_aclk period x (CTLR_START_HOLD + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_START_SETUP</spirit:name>
          <spirit:displayName>PHY_CTLR_START_SETUP</spirit:displayName>
          <spirit:description>Controller PHY Start Setup Control Register</spirit:description>
          <spirit:addressOffset>0x808</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_START_SETUP</spirit:name>
            <spirit:displayName>CTLR_START_SETUP</spirit:displayName>
            <spirit:description>Controller PHY Start Setup
Configure the START condition setup time.
This value must be configured to meet tSU:STA:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Setup Time = s_axi_aclk period x (CTLR_START_SETUP + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Setup Time = s_axi_aclk period x (CTLR_START_SETUP + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_STOP_SETUP</spirit:name>
          <spirit:displayName>PHY_CTLR_STOP_SETUP</spirit:displayName>
          <spirit:description>Controller PHY Stop Setup Control Register</spirit:description>
          <spirit:addressOffset>0x80C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_STOP_SETUP</spirit:name>
            <spirit:displayName>CTLR_STOP_SETUP</spirit:displayName>
            <spirit:description>Controller PHY Stop Setup
Configure the STOP condition setup time.
This value must be configured to meet tSU:STO:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Setup Time = s_axi_aclk period x (CTLR_STOP_SETUP + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Setup Time = s_axi_aclk period x (CTLR_STOP_SETUP + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_CLK_TLOW</spirit:name>
          <spirit:displayName>PHY_CTLR_CLK_TLOW</spirit:displayName>
          <spirit:description>Controller PHY Clock Low Control Register</spirit:description>
          <spirit:addressOffset>0x810</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_CLK_TLOW</spirit:name>
            <spirit:displayName>CTLR_CLK_TLOW</spirit:displayName>
            <spirit:description>Controller PHY Clock Low
Configure the SMBCLK low time.
This value must be configured to meet tLOW:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Low Time = s_axi_aclk period x (CTLR_CLK_TLOW + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Low Time = s_axi_aclk period x (CTLR_CLK_TLOW + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_CLK_THIGH</spirit:name>
          <spirit:displayName>PHY_CTLR_CLK_THIGH</spirit:displayName>
          <spirit:description>Controller PHY Clock High Control Register</spirit:description>
          <spirit:addressOffset>0x814</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_CLK_THIGH</spirit:name>
            <spirit:displayName>CTLR_CLK_THIGH</spirit:displayName>
            <spirit:description>Controller PHY Clock High
Configure the SMBCLK high time.
This value must be configured to meet tHIGH:Min in accordance with the SMBus Specification.
This value is calculated as -
If PHY_FILTER_CONTROL__ENABLE = 0x1
Low Time = s_axi_aclk period x (CTLR_CLK_THIGH + 8 + (PHY_FILTER_CONTROL__DURATION + 1))
If PHY_FILTER_CONTROL__ENABLE = 0x0
Low Time = s_axi_aclk period x (CTLR_CLK_THIGH + 8)
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_TEXT_PRESCALER</spirit:name>
          <spirit:displayName>PHY_CTLR_TEXT_PRESCALER</spirit:displayName>
          <spirit:description>Controller PHY TEXT Timeout Prescaler Control Register</spirit:description>
          <spirit:addressOffset>0x818</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_TEXT_PRESCALER</spirit:name>
            <spirit:displayName>CTLR_TEXT_PRESCALER</spirit:displayName>
            <spirit:description>Controller PHY TEXT Timeout Prescaler Configuration
Configure the amount of time to measure before incrementing the PHY_CTLR_TEXT_TIMEOUT counter when external SMBCLK stretching is detected by the Controller function.
This value is calculated as Text_Prescaler_Time = s_axi_aclk period x (CTLR_TEXT_PRESCALER+ 1)
The Text_Prescaler_Time should be configured for 1us in order to stay within range of the PHY_CTLR_TEXT_TIMEOUT counter.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_TEXT_TIMEOUT</spirit:name>
          <spirit:displayName>PHY_CTLR_TEXT_TIMEOUT</spirit:displayName>
          <spirit:description>Controller PHY TEXT Timeout Control Register</spirit:description>
          <spirit:addressOffset>0x81C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_TEXT_TIMEOUT</spirit:name>
            <spirit:displayName>CTLR_TEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY TEXT Timeout Configuration
Configure the threshold used to detect that an external Target device(s) has exceeded the cumulative clock stretching threshold and to trigger the CTLR_TEXT_TIMEOUT interrupt.
This value must be configured to meet tLOW:TEXT in accordance with the SMBus Specification.
This value is calculated as Text_Timeout_Time = CTLR_TEXT_TIMEOUT x Text_Prescaler_Time
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_TEXT_MAX</spirit:name>
          <spirit:displayName>PHY_CTLR_TEXT_MAX</spirit:displayName>
          <spirit:description>Controller PHY TEXT Timeout Max Status Register</spirit:description>
          <spirit:addressOffset>0x820</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_TEXT_MAX</spirit:name>
            <spirit:displayName>CTLR_TEXT_MAX</spirit:displayName>
            <spirit:description>Controller PHY TEXT Timeout Max
Indicates the maximum amount of cumulative time in Text_Prescaler_Time units that the Controller function has measured external SMBCLK stretching during any single transaction (between an initial START and a STOP).
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>15</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>clear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_CEXT_PRESCALER</spirit:name>
          <spirit:displayName>PHY_CTLR_CEXT_PRESCALER</spirit:displayName>
          <spirit:description>Controller PHY CEXT Timeout Prescaler Configuration Register</spirit:description>
          <spirit:addressOffset>0x824</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_CEXT_PRESCALER</spirit:name>
            <spirit:displayName>CTLR_CEXT_PRESCALER</spirit:displayName>
            <spirit:description>Controller PHY CEXT Timeout Prescaler Configuration
Configure the amount of time to measure before incrementing the PHY_CTLR_CEXT_TIMEOUT counter when SMBCLK stretching is active within the Controller function.
This value is calculated as Cext_Prescaler_Time = s_axi_aclk period x (CTLR_CEXT_PRESCALER+ 1)
The Cext_Prescaler_Time should be configured for 1us in order to stay within range of the PHY_CTLR_CEXT_TIMEOUT counter.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>9</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_CEXT_TIMEOUT</spirit:name>
          <spirit:displayName>PHY_CTLR_CEXT_TIMEOUT</spirit:displayName>
          <spirit:description>Controller PHY CEXT Timeout Configuration Register</spirit:description>
          <spirit:addressOffset>0x828</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_CEXT_TIMEOUT</spirit:name>
            <spirit:displayName>CTLR_CEXT_TIMEOUT</spirit:displayName>
            <spirit:description>Controller PHY CEXT Timeout Configuration
Configure the threshold used to detect that the Controller function has exceeded the cumulative clock stretching threshold and to trigger the CTLR_CEXT_TIMEOUT interrupt.
This value must be configured to meet tLOW:CEXT in accordance with the SMBus Specification.
This value is calculated as Cext_Timeout_Time = CTLR_CEXT_TIMEOUT x Cext_Prescaler_Time
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_CEXT_MAX</spirit:name>
          <spirit:displayName>PHY_CTLR_CEXT_MAX</spirit:displayName>
          <spirit:description>Controller PHY CEXT Timeout Max Status Register</spirit:description>
          <spirit:addressOffset>0x82C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>CTLR_CEXT_MAX</spirit:name>
            <spirit:displayName>CTLR_CEXT_MAX</spirit:displayName>
            <spirit:description>Controller PHY CEXT Timeout Max
Indicates the maximum amount of cumulative time in Cext_Prescaler_Time units that the Controller function has performed SMBCLK stretching during any single byte transfer (START-ACK, ACK-ACK, ACK-STOP).
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>14</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>clear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>PHY_CTLR_DBG_STATE</spirit:name>
          <spirit:displayName>PHY_CTLR_DBG_STATE</spirit:displayName>
          <spirit:description>Controller PHY Debug State Status Register</spirit:description>
          <spirit:addressOffset>0x830</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>DBG_STATE</spirit:name>
            <spirit:displayName>DBG_STATE</spirit:displayName>
            <spirit:description>Controller PHY Debug State
Reports the current Controller PHY FSM State to assist with debug.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_CONTROL</spirit:name>
          <spirit:displayName>CTLR_CONTROL</spirit:displayName>
          <spirit:description>Controller Enable Control Register</spirit:description>
          <spirit:addressOffset>0xA00</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Controller Enable Control
Enable the Controller to begin executing the descriptors in the Descriptor FIFO.
0x0 - Controller not enabled
0x1 - Controller enabled to execute the descriptors
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_STATUS</spirit:name>
          <spirit:displayName>CTLR_STATUS</spirit:displayName>
          <spirit:description>Controller Enable Status Register</spirit:description>
          <spirit:addressOffset>0xA04</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>ENABLE</spirit:name>
            <spirit:displayName>ENABLE</spirit:displayName>
            <spirit:description>Controller Enable Status
0x0 - Controller is disabled
0x1 - Controller is enabled
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_DESC_FIFO</spirit:name>
          <spirit:displayName>CTLR_DESC_FIFO</spirit:displayName>
          <spirit:description>Controller Descriptor FIFO Control Register</spirit:description>
          <spirit:addressOffset>0xA08</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>write-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RESET</spirit:name>
            <spirit:displayName>RESET</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Reset Control
When set the Controller Descriptor FIFO is reset to a known state.
Poll the RESET_BUSY field in the CTLR_DESC_STATUS register to determine when the reset is complete.
0x1 - Descriptor FIFO reset
0x0 - Descriptor FIFO not reset
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ID</spirit:name>
            <spirit:displayName>ID</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO ID
Configure the next Controller Descriptor ID
Writing this register when the RESET field is 0x0 pushes a value into the Controller Descriptor FIFO
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>4</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAYLOAD</spirit:name>
            <spirit:displayName>PAYLOAD</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Payload
Configure the next Controller Descriptor payload
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_DESC_STATUS</spirit:name>
          <spirit:displayName>CTLR_DESC_STATUS</spirit:displayName>
          <spirit:description>Controller Descriptor FIFO Status Register</spirit:description>
          <spirit:addressOffset>0xA0C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FILL_LEVEL</spirit:name>
            <spirit:displayName>FILL_LEVEL</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Fill Level
Indicates the current fill level of the Descriptor FIFO
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESET_BUSY</spirit:name>
            <spirit:displayName>RESET_BUSY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Reset Busy
Indicates if the Descriptor FIFO is currently undergoing a reset and is unavailable for either read or write.
0x0 - FIFO not in reset
0x1 - FIFO reset in progress
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FULL</spirit:name>
            <spirit:displayName>FULL</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Full
Indicates if the Descriptor FIFO is full
0x0 - FIFO not full
0x1 - FIFO full
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_FULL</spirit:name>
            <spirit:displayName>ALMOST_FULL</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Almost Full
Indicates if the Descriptor FIFO is almost full
0x0 - FIFO has space for more than one descriptor
0x1 - FIFO only has space for one more descriptor
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_EMPTY</spirit:name>
            <spirit:displayName>ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Almost Empty
Indicates if the Descriptor FIFO is almost empty
0x0 - FIFO contains more than one descriptor
0x1 - FIFO contains one descriptor or less
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EMPTY</spirit:name>
            <spirit:displayName>EMPTY</spirit:displayName>
            <spirit:description>Controller Descriptor FIFO Empty
Indicates if the Descriptor FIFO is empty
0x0 - FIFO not empty
0x1 - FIFO empty
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_RX_FIFO</spirit:name>
          <spirit:displayName>CTLR_RX_FIFO</spirit:displayName>
          <spirit:description>Controller Receive FIFO Control Register</spirit:description>
          <spirit:addressOffset>0xA10</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>RESET</spirit:name>
            <spirit:displayName>RESET</spirit:displayName>
            <spirit:description>Controller Receive FIFO Reset Control
When set the Controller Recieve FIFO is reset to a known state.
Poll the RESET_BUSY field in the CTLR_RX_FIFO_STATUS register to determine when the reset is complete.
0x0 - FIFO not reset
0x1 - FIFO reset
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>write-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>PAYLOAD</spirit:name>
            <spirit:displayName>PAYLOAD</spirit:displayName>
            <spirit:description>Controller Receive FIFO Payload
Receive payload byte for the Controller function.
Reading this register pops a value from the Controller Receive FIFO.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>8</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:readAction>modify</spirit:readAction>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_RX_FIFO_STATUS</spirit:name>
          <spirit:displayName>CTLR_RX_FIFO_STATUS</spirit:displayName>
          <spirit:description>Controller Receive FIFO Status Register</spirit:description>
          <spirit:addressOffset>0xA14</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x0</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>MAX_FILL_LEVEL</spirit:name>
            <spirit:displayName>MAX_FILL_LEVEL</spirit:displayName>
            <spirit:description>Controller Receive FIFO Max Fill Level Status
Indicates the maximum recorded fill level of the Controller Receive FIFO.
</spirit:description>
            <spirit:bitOffset>16</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:modifiedWriteValue>oneToClear</spirit:modifiedWriteValue>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FILL_LEVEL</spirit:name>
            <spirit:displayName>FILL_LEVEL</spirit:displayName>
            <spirit:description>Controller Receive FIFO Fill Level
Indicates the current fill level of the Receive FIFO.
</spirit:description>
            <spirit:bitOffset>8</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>RESET_BUSY</spirit:name>
            <spirit:displayName>RESET_BUSY</spirit:displayName>
            <spirit:description>Controller Receive FIFO Reset Empty
Indicates if the Receive FIFO is currently undergoing a reset and is unavailable for either read or write.
0x0 - FIFO not in reset
0x1 - FIFO reset in progress
</spirit:description>
            <spirit:bitOffset>6</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>FULL</spirit:name>
            <spirit:displayName>FULL</spirit:displayName>
            <spirit:description>Controller Receive FIFO Full
Indicates if the Receive FIFO is full
0x0 - FIFO not full
0x1 - FIFO full
</spirit:description>
            <spirit:bitOffset>5</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_FULL</spirit:name>
            <spirit:displayName>ALMOST_FULL</spirit:displayName>
            <spirit:description>Controller Receive FIFO Almost Full
Indicates if the Controller Receive FIFO is almost full
0x0 - FIFO has space for two or more bytes
0x1 - FIFO has space for only one more byte
</spirit:description>
            <spirit:bitOffset>4</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>ALMOST_EMPTY</spirit:name>
            <spirit:displayName>ALMOST_EMPTY</spirit:displayName>
            <spirit:description>Controller Receive FIFO Almost Empty
Indicates if the Controller Receive FIFO is almost empty
0x0 - FIFO contains more than one byte
0x1 - FIFO contains one byte or less
</spirit:description>
            <spirit:bitOffset>1</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>EMPTY</spirit:name>
            <spirit:displayName>EMPTY</spirit:displayName>
            <spirit:description>Controller Receive FIFO Empty
Indicates if the Receive FIFO is empty
0x0 - FIFO not empty
0x1 - FIFO empty
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:name>
          <spirit:displayName>CTLR_RX_FIFO_FILL_THRESHOLD</spirit:displayName>
          <spirit:description>Controller Receive FIFO Fill Threshold Control Register</spirit:description>
          <spirit:addressOffset>0xA18</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-write</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FILL_THRESHOLD</spirit:name>
            <spirit:displayName>FILL_THRESHOLD</spirit:displayName>
            <spirit:description>Controller Receive FIFO Fill Threshold
Configure the Controller Receive FIFO fill threshold that should assert the CTLR_RX_FIFO_FILL_THRESHOLD interrupt.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
        <spirit:register>
          <spirit:name>CTLR_DBG</spirit:name>
          <spirit:displayName>CTLR_DBG</spirit:displayName>
          <spirit:description>Controller Debug Register</spirit:description>
          <spirit:addressOffset>0xA1C</spirit:addressOffset>
          <spirit:size spirit:format="long">32</spirit:size>
          <spirit:access>read-only</spirit:access>
          <spirit:reset>
            <spirit:value spirit:format="long">0x1</spirit:value>
          </spirit:reset>
          <spirit:field>
            <spirit:name>FORCE_PEC_ERROR</spirit:name>
            <spirit:displayName>FORCE_PEC_ERROR</spirit:displayName>
            <spirit:description>Controller Debug Force PEC Error
Corrupts the PEC byte generation/checking. When set, reads with PEC enabled will always report an error and the PEC byte transmitted during a write will be corrupted.
0x0 - PEC Error insertion disabled
0x1 - PEC Error insertion enabled
</spirit:description>
            <spirit:bitOffset>31</spirit:bitOffset>
            <spirit:bitWidth>1</spirit:bitWidth>
            <spirit:access>read-write</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
          <spirit:field>
            <spirit:name>DBG_STATE</spirit:name>
            <spirit:displayName>DBG_STATE</spirit:displayName>
            <spirit:description>Controller Debug State
Reports the current Controller FSM State to assist with debug.
</spirit:description>
            <spirit:bitOffset>0</spirit:bitOffset>
            <spirit:bitWidth>7</spirit:bitWidth>
            <spirit:access>read-only</spirit:access>
            <spirit:writeValueConstraint>
              <spirit:minimum>0</spirit:minimum>
              <spirit:maximum>0</spirit:maximum>
            </spirit:writeValueConstraint>
            <spirit:testable spirit:testConstraint="unconstrained">false</spirit:testable>
          </spirit:field>
        </spirit:register>
      </spirit:addressBlock>
    </spirit:memoryMap>
  </spirit:memoryMaps>
  <spirit:model>
    <spirit:views>
      <spirit:view>
        <spirit:name>xilinx_blockdiagram</spirit:name>
        <spirit:displayName>Block Diagram</spirit:displayName>
        <spirit:envIdentifier>:vivado.xilinx.com:block.diagram</spirit:envIdentifier>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_blockdiagram_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>viewChecksum</spirit:name>
            <spirit:value>2e56b7b3</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_xpgui</spirit:name>
        <spirit:displayName>UI Layout</spirit:displayName>
        <spirit:envIdentifier>:vivado.xilinx.com:xgui.ui</spirit:envIdentifier>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_xpgui_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>viewChecksum</spirit:name>
            <spirit:value>cf724b7d</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_verilogbehavioralsimulation</spirit:name>
        <spirit:displayName>Verilog Simulation</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:simulation</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>smbus_v1_1_0</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogbehavioralsimulation_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>viewChecksum</spirit:name>
            <spirit:value>7231790d</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_verilogsynthesis</spirit:name>
        <spirit:displayName>Verilog Synthesis</spirit:displayName>
        <spirit:envIdentifier>verilogSource:vivado.xilinx.com:synthesis</spirit:envIdentifier>
        <spirit:language>verilog</spirit:language>
        <spirit:modelName>smbus_v1_1_0</spirit:modelName>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_verilogsynthesis_view_fileset</spirit:localName>
        </spirit:fileSetRef>
        <spirit:parameters>
          <spirit:parameter>
            <spirit:name>viewChecksum</spirit:name>
            <spirit:value>7231790d</spirit:value>
          </spirit:parameter>
        </spirit:parameters>
      </spirit:view>
      <spirit:view>
        <spirit:name>xilinx_versioninformation</spirit:name>
        <spirit:displayName>Version Information</spirit:displayName>
        <spirit:envIdentifier>:vivado.xilinx.com:docs.versioninfo</spirit:envIdentifier>
        <spirit:fileSetRef>
          <spirit:localName>xilinx_versioninformation_view_fileset</spirit:localName>
        </spirit:fileSetRef>
      </spirit:view>
    </spirit:views>
    <spirit:ports>
      <spirit:port>
        <spirit:name>s_axi_aclk</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_aresetn</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awaddr</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_ADDR_WIDTH&apos;)) - 1)">11</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_awready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wdata</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wstrb</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">3</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_wready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bresp</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">1</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_bready</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_araddr</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long" spirit:resolve="dependent" spirit:dependency="(spirit:decode(id(&apos;MODELPARAM_VALUE.C_ADDR_WIDTH&apos;)) - 1)">11</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_arvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_arready</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rdata</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">31</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rresp</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:vector>
            <spirit:left spirit:format="long">1</spirit:left>
            <spirit:right spirit:format="long">0</spirit:right>
          </spirit:vector>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rvalid</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>s_axi_rready</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>ip2intc_irpt</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbclk_i</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbclk_o</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbclk_t</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbdat_i</spirit:name>
        <spirit:wire>
          <spirit:direction>in</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbdat_o</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
      <spirit:port>
        <spirit:name>smbdat_t</spirit:name>
        <spirit:wire>
          <spirit:direction>out</spirit:direction>
          <spirit:wireTypeDefs>
            <spirit:wireTypeDef>
              <spirit:typeName>wire</spirit:typeName>
              <spirit:viewNameRef>xilinx_verilogsynthesis</spirit:viewNameRef>
              <spirit:viewNameRef>xilinx_verilogbehavioralsimulation</spirit:viewNameRef>
            </spirit:wireTypeDef>
          </spirit:wireTypeDefs>
        </spirit:wire>
      </spirit:port>
    </spirit:ports>
    <spirit:modelParameters>
      <spirit:modelParameter xsi:type="spirit:nameValueTypeType" spirit:dataType="integer">
        <spirit:name>C_ADDR_WIDTH</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_ADDR_WIDTH">12</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_SMBUS_DEV_CLASS</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_SMBUS_DEV_CLASS">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_NUM_TARGET_DEVICES</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_NUM_TARGET_DEVICES">8</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_FREQ_HZ_AXI_ACLK</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_FREQ_HZ_AXI_ACLK">100000000</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_MINOR_VERSION</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_MINOR_VERSION">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_MAJOR_VERSION</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_MAJOR_VERSION">1</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_CORE_REVISION</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_CORE_REVISION">0</spirit:value>
      </spirit:modelParameter>
      <spirit:modelParameter spirit:dataType="integer">
        <spirit:name>C_PATCH_REVISION</spirit:name>
        <spirit:value spirit:format="long" spirit:resolve="generated" spirit:id="MODELPARAM_VALUE.C_PATCH_REVISION">0</spirit:value>
      </spirit:modelParameter>
    </spirit:modelParameters>
  </spirit:model>
  <spirit:choices>
    <spirit:choice>
      <spirit:name>choice_list_74b5137e</spirit:name>
      <spirit:enumeration>ACTIVE_HIGH</spirit:enumeration>
      <spirit:enumeration>ACTIVE_LOW</spirit:enumeration>
    </spirit:choice>
    <spirit:choice>
      <spirit:name>choice_pairs_3721d737</spirit:name>
      <spirit:enumeration spirit:text="100KHz">0</spirit:enumeration>
      <spirit:enumeration spirit:text="400KHz">1</spirit:enumeration>
      <spirit:enumeration spirit:text="1MHz">2</spirit:enumeration>
    </spirit:choice>
  </spirit:choices>
  <spirit:fileSets>
    <spirit:fileSet>
      <spirit:name>xilinx_blockdiagram_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>bd/bd.tcl</spirit:name>
        <spirit:fileType>tclSource</spirit:fileType>
        <spirit:logicalName>smbus_v1_1_0</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_xpgui_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>xgui/smbus_v1_1.tcl</spirit:name>
        <spirit:fileType>tclSource</spirit:fileType>
        <spirit:userFileType>XGUI_VERSION_2</spirit:userFileType>
        <spirit:logicalName>smbus_v1_1_0</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogbehavioralsimulation_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>hdl/smbus_v1_1_vl_rfs.sv</spirit:name>
        <spirit:fileType>systemVerilogSource</spirit:fileType>
        <spirit:userFileType>USED_IN_ipstatic</spirit:userFileType>
        <spirit:logicalName>smbus_v1_1_0</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_verilogsynthesis_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>hdl/smbus_v1_1_vl_rfs.sv</spirit:name>
        <spirit:fileType>systemVerilogSource</spirit:fileType>
        <spirit:userFileType>CHECKSUM_7231790d</spirit:userFileType>
        <spirit:logicalName>smbus_v1_1_0</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
    <spirit:fileSet>
      <spirit:name>xilinx_versioninformation_view_fileset</spirit:name>
      <spirit:file>
        <spirit:name>doc/smbus_v1_1_changelog.txt</spirit:name>
        <spirit:userFileType>text</spirit:userFileType>
        <spirit:logicalName>smbus_v1_1_0</spirit:logicalName>
      </spirit:file>
    </spirit:fileSet>
  </spirit:fileSets>
  <spirit:description>SMBus v3.2 Compliant Target/Controller IP</spirit:description>
  <spirit:parameters>
    <spirit:parameter>
      <spirit:name>Component_Name</spirit:name>
      <spirit:value spirit:resolve="user" spirit:id="PARAM_VALUE.Component_Name" spirit:order="1">smbus_v1_1</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>NUM_TARGET_DEVICES</spirit:name>
      <spirit:displayName>Target Devices</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.NUM_TARGET_DEVICES" spirit:order="2" spirit:minimum="1" spirit:maximum="8" spirit:rangeType="long">8</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>SMBUS_DEV_CLASS</spirit:name>
      <spirit:displayName>Default SMBus Device Class</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.SMBUS_DEV_CLASS" spirit:choiceRef="choice_pairs_3721d737" spirit:order="3">0</spirit:value>
    </spirit:parameter>
    <spirit:parameter>
      <spirit:name>FREQ_HZ_AXI_ACLK</spirit:name>
      <spirit:displayName>S_AXI Clock Frequency (Hz)</spirit:displayName>
      <spirit:value spirit:format="long" spirit:resolve="user" spirit:id="PARAM_VALUE.FREQ_HZ_AXI_ACLK" spirit:order="4" spirit:minimum="95000000" spirit:maximum="500000000" spirit:rangeType="long">100000000</spirit:value>
    </spirit:parameter>
  </spirit:parameters>
  <spirit:vendorExtensions>
    <xilinx:coreExtensions>
      <xilinx:taxonomies>
        <xilinx:taxonomy>/Alveo</xilinx:taxonomy>
      </xilinx:taxonomies>
      <xilinx:displayName>SMBus</xilinx:displayName>
      <xilinx:autoFamilySupportLevel>level_2</xilinx:autoFamilySupportLevel>
      <xilinx:autoDevicePropertiesFilter>(GENERIC_FAMILY = versal)</xilinx:autoDevicePropertiesFilter>
      <xilinx:xpmLibraries>
        <xilinx:xpmLibrary>XPM_CDC</xilinx:xpmLibrary>
        <xilinx:xpmLibrary>XPM_MEMORY</xilinx:xpmLibrary>
        <xilinx:xpmLibrary>XPM_FIFO</xilinx:xpmLibrary>
      </xilinx:xpmLibraries>
      <xilinx:vendorURL>http://www.xilinx.com</xilinx:vendorURL>
      <xilinx:coreRevision>0</xilinx:coreRevision>
      <xilinx:licenseKeys>
        <xilinx:licenseKey>smbus@2022.10</xilinx:licenseKey>
      </xilinx:licenseKeys>
      <xilinx:paymentRequired>true</xilinx:paymentRequired>
      <xilinx:coreCreationDateTime>2024-02-15T09:40:36Z</xilinx:coreCreationDateTime>
    </xilinx:coreExtensions>
    <xilinx:packagingInfo>
      <xilinx:xilinxVersion>2023.2</xilinx:xilinxVersion>
      <xilinx:checksum xilinx:scope="busInterfaces" xilinx:value="3df41646"/>
      <xilinx:checksum xilinx:scope="memoryMaps" xilinx:value="68878b2d"/>
      <xilinx:checksum xilinx:scope="fileGroups" xilinx:value="48812196"/>
      <xilinx:checksum xilinx:scope="ports" xilinx:value="cac64ed3"/>
      <xilinx:checksum xilinx:scope="hdlParameters" xilinx:value="7a0088e3"/>
      <xilinx:checksum xilinx:scope="parameters" xilinx:value="9701aeca"/>
    </xilinx:packagingInfo>
  </spirit:vendorExtensions>
</spirit:component>
